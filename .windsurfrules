# Terrarium Project Development Rules

You are an AI assistant helping with the Terrarium project, a multi-tenant community platform.

## Project Context

- Tech Stack:
  - Frontend: React 18+ with TypeScript, Vite, TailwindCSS
  - State: Jotai (global), React Query (server)
  - Backend: Supabase (auth, database)
  - Forms: React Hook Form + Zod
  - UI: Radix UI components
  - Analytics: Chart.js
- Architecture: Multi-tenant SaaS platform
- Current Phase: Setting up development environment and infrastructure

### User Types

- Platform Owners: Full platform administration
- Community Owners: Community management and customization
- Members: Job discovery and community engagement
- Employers: Job posting and talent access

### Key Features

- Custom Job Boards
- Community Management
- Analytics Dashboard
- Branding Controls

## Code Generation Rules

### 1. TypeScript Best Practices

- Always use TypeScript for type safety
- Use interfaces for object shapes
- Use proper type annotations
- Avoid 'any' type
- Use enums for fixed values

Example:

```typescript
// ✅ Good
interface User {
  id: string;
  email: string;
  role: UserRole;
}

enum UserRole {
  ADMIN = 'ADMIN',
  MEMBER = 'MEMBER',
}

// ❌ Bad
const user: any = {
  /* ... */
};
```

### 2. React Component Structure

- Use functional components with hooks
- Implement proper prop typing
- Use proper file naming (PascalCase for components)
- Keep components focused and small
- Implement error boundaries

Example:

```typescript
// ✅ Good
interface ProfileCardProps {
  user: User;
  onEdit?: (user: User) => void;
}

const ProfileCard: React.FC<ProfileCardProps> = ({ user, onEdit }) => {
  return (/* ... */);
};

// ❌ Bad
function profile(p) {
  return (/* ... */);
}
```

### 3. State Management

- Use React Query for server state
- Use Zustand for client state
- Keep state logic separated
- Implement proper loading states
- Handle errors gracefully

Example:

```typescript
// ✅ Good
const useUsers = () => {
  return useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
  });
};

// ❌ Bad
const [users, setUsers] = useState([]);
useEffect(() => {
  fetch('/users').then(setUsers);
}, []);
```

### 4. API and Data Handling

- Use repository pattern
- Implement proper error handling
- Use data validation
- Include proper typing
- Handle loading states

Example:

```typescript
// ✅ Good
class APIError extends Error {
  constructor(
    public statusCode: number,
    public code: string,
    message: string
  ) {
    super(message);
  }
}

// ❌ Bad
throw new Error('Something went wrong');
```

### 5. File Structure

- Follow project structure guidelines
- Use proper file naming conventions
- Keep related files together
- Implement proper imports
- Use index files for exports

Example:

```typescript
// ✅ Good
// src/features/users/components/UserProfile.tsx
import { User } from '../types';
import { useUser } from '../hooks';

// ❌ Bad
// random/profile.js
import { User } from '../../../somewhere';
```

## Project Structure Overview

```
terrarium/
├── src/
│   ├── api/                # API client configurations and endpoints
│   │   └── routes/        # API route definitions
│   ├── components/
│   │   ├── platform/      # Platform owner dashboard components
│   │   ├── charts/        # Data visualization components
│   │   ├── features/      # Feature-specific components
│   │   │   ├── platform/  # Platform owner features
│   │   │   ├── auth/      # Authentication components
│   │   │   ├── communities/ # Community management
│   │   │   ├── customization/ # UI customization
│   │   │   ├── events/    # Event management
│   │   │   ├── feed/      # Activity feed
│   │   │   ├── jobs/      # Job board components
│   │   │   │   ├── JobList.tsx
│   │   │   │   ├── JobFilters.tsx
│   │   │   │   └── SelectedFilters.tsx
│   │   │   ├── member-hub/ # Member hub components
│   │   │   ├── members/   # Member management
│   │   │   ├── onboarding/ # User onboarding
│   │   │   ├── profile/   # User profile
│   │   │   └── settings/  # App settings
│   │   ├── layout/       # Layout components
│   │   │   ├── MainLayout.tsx
│   │   │   └── CommunityLayout.tsx
│   │   ├── onboarding/   # Onboarding flows
│   │   └── ui/           # Reusable UI components
│   │       ├── atoms/    # Basic UI elements
│   │       └── molecules/ # Composite components
│   ├── lib/              # Core library code
│   │   ├── api/          # API utilities
│   │   ├── atoms/        # Atomic state primitives
│   │   ├── constants/    # Application constants
│   │   ├── data/         # Data utilities
│   │   ├── hooks/        # Custom React hooks
│   │   │   ├── useJobs.ts
│   │   │   ├── useScrollSync.ts
│   │   │   └── useScrollEnd.ts
│   │   ├── mocks/        # Test mocks
│   │   ├── stores/       # State management
│   │   ├── types/        # TypeScript types
│   │   └── utils/        # Utility functions
│   ├── pages/            # Page components
│   │   ├── platform/     # Platform owner pages
│   │   ├── auth/         # Authentication pages
│   │   ├── community/    # Community pages
│   │   ├── member/       # Member pages
│   │   ├── Communities.tsx
│   │   ├── JobBoard.tsx
│   │   └── LandingPage.tsx
│   ├── services/         # Service layer
│   ├── stores/           # Global state
│   ├── styles/           # Global styles
│   └── utils/            # Utility functions
├── docs/                 # Documentation
└── public/              # Static assets
```

## Component Organization

### Features

Feature-specific components are organized by domain:

#### Platform

- Platform owner dashboard components
- Community oversight tools
- User management interfaces

#### Authentication

- Login/Register forms
- Authentication flows
- Password reset

#### Communities

- Community creation
- Community settings
- Member management

#### Jobs

- `JobList.tsx`: Job card grid with infinite scroll
- `JobFilters.tsx`: Filter sidebar
- `SelectedFilters.tsx`: Active filter display

#### Member Hub

- `Header.tsx`: Navigation header
- `MemberFooter.tsx`: Footer component
- Profile management
- Activity feeds

### Layout

- `MainLayout.tsx`: Application shell
- `CommunityLayout.tsx`: Community-specific layout

### UI Components

- **Atoms**: Buttons, inputs, icons
- **Molecules**: Forms, cards, modals

## Core Libraries

### Hooks

- Authentication hooks
- Data fetching hooks
- UI utility hooks
- Scroll management hooks

### State Management

- Jotai atoms for global state
- Community state
- User state
- UI state

### Services

- API services
- Authentication services
- Data services
- File upload services

## Pages

### Platform

- Dashboard
- User management
- Settings

### Auth

- Login
- Register
- Password reset

### Community

- Community home
- Member management
- Events
- Jobs

### Member

- Profile
- Settings
- Activity

## Best Practices

1. **Component Organization**

   - Feature-first architecture
   - Clear separation of concerns
   - Reusable UI components

2. **State Management**

   - Jotai for global state
   - React Query for server state
   - Local state when appropriate

3. **Type Safety**

   - Comprehensive type definitions
   - Strict type checking
   - Interface-first development

4. **Code Style**
   - Consistent file naming
   - Clear component structure
   - Proper documentation

## Future Considerations

1. **Scalability**

   - Code splitting strategies
   - Performance optimization
   - Caching strategies

2. **Maintainability**

   - Testing strategy
   - Documentation updates
   - Code review process

3. **Feature Expansion**
   - New feature integration
   - State management scaling
   - Component reusability

### 6. Documentation

- Add JSDoc comments for functions
- Document complex logic
- Include usage examples
- Document props and types
- Keep documentation up to date

Example:

```typescript
// ✅ Good
/**
 * Fetches user profile data
 * @param userId - The user's unique identifier
 * @returns User profile data
 * @throws {APIError} If user not found
 */
const fetchUserProfile = async (userId: string): Promise<UserProfile> => {
  // ...
};

// ❌ Bad
const getUser = (id) => {
  // ...
};
```

### 7. Testing

- Write unit tests for logic
- Test components with React Testing Library
- Include error cases
- Test loading states
- Mock external dependencies

Example:

```typescript
// ✅ Good
describe('UserProfile', () => {
  it('should display loading state', () => {
    render(<UserProfile userId="123" />);
    expect(screen.getByRole('progressbar')).toBeInTheDocument();
  });
});

// ❌ Bad
test('it works', () => {
  expect(true).toBe(true);
});
```

### 8. Error Handling

- Use proper error boundaries
- Implement proper error types
- Handle async errors
- Show user-friendly messages
- Log errors properly

Example:

```typescript
// ✅ Good
try {
  await api.createUser(userData);
} catch (error) {
  if (error instanceof APIError) {
    logger.error('API Error:', { error, userData });
    throw error;
  }
  throw new APIError(500, 'UNKNOWN_ERROR', 'An unexpected error occurred');
}

// ❌ Bad
try {
  await api.createUser(userData);
} catch (e) {
  console.log(e);
}
```

### 9. Security

- Validate all inputs
- Sanitize outputs
- Use proper authentication
- Implement proper authorization
- Handle sensitive data carefully

Example:

```typescript
// ✅ Good
const createUser = async (data: CreateUserDTO) => {
  const validated = UserSchema.parse(data);
  return await userRepository.create(validated);
};

// ❌ Bad
const createUser = async (data) => {
  return await db.users.create(data);
};
```

### 10. Performance

- Implement proper memoization
- Use proper loading strategies
- Optimize renders
- Handle large lists properly
- Implement proper caching

Example:

```typescript
// ✅ Good
const MemoizedComponent = React.memo(({ data }) => {
  return <div>{data.map(renderItem)}</div>;
});

// ❌ Bad
const Component = ({ data }) => {
  return <div>{data.map(item => <span>{item}</span>)}</div>;
};
```

## Frontend Preservation Rules

### 1. Design Lock

- Never modify existing UI/UX design without explicit request
- Preserve all Tailwind CSS classes exactly as they are
- Keep component structure and hierarchy unchanged
- Maintain existing animations and transitions
- Preserve all accessibility attributes

Example:

```typescript
// ✅ Good: Add functionality while preserving design
function JobCard({ job }: JobCardProps) {
  const existingComponent = (
    <div className="existing-classes">
      {/* Existing UI structure */}
    </div>
  );

  return existingComponent;
}

// ❌ Bad: Modifying existing design
function JobCard({ job }: JobCardProps) {
  return (
    <div className="different-classes">
      {/* Modified UI structure */}
    </div>
  );
}
```

### 2. Component Modification Rules

- Only modify component logic, not presentation
- Keep all existing props and their types
- Maintain current component file structure
- Don't change component naming conventions
- Preserve all comments about design decisions

Example:

```typescript
// ✅ Good: Adding functionality without changing design
interface JobCardProps {
  job: Job;
  onApply: (jobId: string) => void; // New prop
}

// ❌ Bad: Changing existing component structure
interface JobCardProps {
  jobData: Job; // Changed prop name
  layout: 'grid' | 'list'; // New visual prop
}
```

### 3. File Organization

```
src/
├── components/
│   ├── ui/           # Locked UI components
│   │   └── [...]     # Don't modify without request
│   ├── features/     # Feature components
│   │   └── [...]     # Can add logic, not design
│   └── layouts/      # Layout components
│       └── [...]     # Don't modify without request
├── styles/          # Locked styles
└── theme/           # Locked theme configuration
```

## AI Interaction Strategy

### 1. Task Separation

- Clearly separate frontend and backend tasks
- Specify if a task requires UI changes
- Use explicit "preserve design" flags in requests
- Indicate which components are design-locked

Example Request Format:

```markdown
Task: Implement job application logic
Type: Backend Implementation
Design Status: Locked
Affected Components:

- JobCard (logic only)
- JobList (logic only)
  UI Changes Required: No
```

### 2. Implementation Order

1. First implement all backend functionality
2. Then add state management and data flow
3. Finally, connect to existing UI components
4. Never modify UI during steps 1-3

### 3. Review Process

- Review all proposed changes for UI modifications
- Verify no design classes were altered
- Check component structure preservation
- Ensure accessibility features remain intact
- Confirm animations and transitions are preserved

### 4. Documentation Requirements

- Document all backend changes separately
- Mark frontend components as "design-locked"
- Keep separate changelogs for UI and logic
- Include "preserve-design" tags in comments

Example Documentation:

```typescript
/**
 * @component JobCard
 * @preserve-design
 * @last-design-update 2024-12-20
 *
 * This component's UI/UX is locked.
 * Only modify the following:
 * - Data fetching
 * - Event handlers
 * - State management
 */
```

### AI Context Documentation

Every file must include an AI Context comment block that explains:

1. Purpose and Responsibility

   - What the file does
   - Its role in the system
   - Key features or functions

2. Location Justification

   - Why it's in this directory
   - Relationship to nearby files
   - Alternative locations considered

3. Design Constraints
   - UI/UX limitations
   - Performance requirements
   - Security considerations

Example:

````typescript
/**
 * AI Context:
 * This component implements the community-specific login page. It's in the pages
 * directory because it represents a full page with its own route (/c/:slug/login).
 *
 * Responsibilities:
 * - Loads community branding (logo, colors, text)
 * - Handles user authentication
 * - Manages form state and validation
 *
 * Design Constraints:
 * - Must use existing UI components
 * - Must preserve Tailwind classes
 * - Must maintain accessibility
 *
 * Future Considerations:
 * - Login form could be extracted to features/
 * - Could add SSO providers
 */

When to Add:

All new files or older files without it must include AI Context
When substantially modifying existing files
When moving or renaming files
When changing file responsibilities


## Multi-Tenant Architecture Rules

### 1. Data Isolation
- Use RLS policies for tenant isolation
- Include community_id in relevant tables
- Validate tenant context in queries

### 2. Feature Customization
- Store community settings in JSONB
- Use feature flags for tenant features
- Implement proper caching strategies

### 3. Security
- Validate tenant access in middleware
- Implement proper role checks
- Handle cross-tenant requests carefully

Example:

```typescript
// ✅ Good: Proper tenant isolation
const getCommunityMembers = async (communityId: string) => {
  const { data, error } = await supabase
    .from('members')
    .select('*')
    .eq('community_id', communityId);
  // RLS will automatically filter by community_id
};

// ❌ Bad: No tenant isolation
const getAllMembers = async () => {
  const { data } = await supabase
    .from('members')
    .select('*');
  // This could leak data across communities
};

## Implementation Guidelines

When implementing new features:

1. Start with types and interfaces
2. Implement data layer (API, repositories)
3. Create React components
4. Add proper error handling
5. Include tests
6. Add documentation

## Learning Resources

For TypeScript:

- TypeScript Handbook: https://www.typescriptlang.org/docs/handbook/intro.html
- React TypeScript Cheatsheet: https://react-typescript-cheatsheet.netlify.app/

For React:

- React Documentation: https://react.dev/
- React Query Documentation: https://tanstack.com/query/latest/

For Testing:

- React Testing Library: https://testing-library.com/docs/react-testing-library/intro/
- Jest Documentation: https://jestjs.io/docs/getting-started

## Code Review Checklist

## Code Review Checklist

Before submitting code:

1. Types are properly defined
2. Components are properly typed
3. Error handling is implemented
4. Tests are included
5. Documentation is updated
   - AI Context is included
   - JSDoc comments are present
   - Design constraints are documented
6. Performance is considered
7. Security is implemented
   - Tenant isolation is enforced
   - RLS policies are in place
8. Code is properly formatted
9. UI preservation rules are followed
10. Multi-tenant rules are followed

## Getting Help

When stuck:

1. Check documentation first
2. Look for similar implementations in the codebase
3. Ask for help in code reviews
4. Use the learning resources provided
````
