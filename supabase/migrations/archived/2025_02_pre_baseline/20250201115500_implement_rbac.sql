-- Create role enum if it doesn't exist
DO $$ BEGIN
    CREATE TYPE public.app_role AS ENUM ('owner', 'admin', 'member', 'employer');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Create user roles table
create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  role app_role not null,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- Create auth hook function
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
security definer
as $$
declare
  claims jsonb;
  user_role public.app_role;
begin
  -- Fetch the user role in the user_roles table
  select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;

  claims := event->'claims';

  if user_role is not null then
    -- Set the claim
    claims := jsonb_set(claims, '{role}', to_jsonb(user_role));
  else
    -- Default to member if no role is set
    claims := jsonb_set(claims, '{role}', '"member"');
  end if;

  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);

  -- Return the modified event
  return event;
end;
$$;

-- Grant necessary permissions
grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;

grant all
  on table public.user_roles
  to supabase_auth_admin;

revoke all
  on table public.user_roles
  from authenticated, anon, public;

-- Create policy to allow auth admin to read user roles
create policy "Allow auth admin to read user roles" on public.user_roles
as permissive for select
to supabase_auth_admin
using (true);

-- Update auth trigger to use user_roles table
create or replace function public.handle_auth_user_created()
returns trigger
security definer
as $$
declare
  new_role public.app_role;
begin
  -- Log the event
  raise log 'Auth trigger executing for user % with metadata %', new.id, new.raw_user_meta_data;
  
  -- Determine role from metadata
  if new.raw_user_meta_data->>'role' is not null then
    new_role := (new.raw_user_meta_data->>'role')::public.app_role;
  else
    new_role := 'member'::public.app_role;
  end if;

  -- Log role assignment
  raise log 'Setting role to %', new_role;

  -- Insert into user_roles
  insert into public.user_roles (user_id, role)
  values (new.id, new_role);

  -- Create profile
  insert into public.profiles (
    id,
    email,
    full_name,
    role,
    onboarding_complete,
    created_at,
    updated_at
  ) values (
    new.id,
    new.email,
    new.raw_user_meta_data->>'full_name',
    new_role,
    false,
    now(),
    now()
  );

  -- Log profile creation
  raise log 'Profile created for user % with role %', new.id, new_role;

  return new;
end;
$$
language plpgsql;

-- Drop old trigger if it exists
drop trigger if exists on_auth_user_created on auth.users;

-- Create new trigger
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_auth_user_created();
